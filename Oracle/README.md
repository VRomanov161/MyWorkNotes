### Instance состоит из:
>SGA (System Global Area), которая обеспечивает коммуникацию между процессами;
бэкграундовых процессов

# Файлы базы данных Oracle

### Физическая структура

Физическая структура БД Oracle определяется файлами операционной системы которые обеспечивают физическое хранение информации в базе данных.

Это действительные файлы данных Oracle на уровне операционной системы.

База данных Oracle может включать в себя физические файлы 3-х основных типов:
```

•   control files — управляющие файлы;
•   data files — файлы данных;
•   redo log files — журнальные файлы либо журналы.
```

В дополнение к этим трем типам файлов база данных Oracle использует несколько других системных файлов операционной системы. Сюда относятся инициализационные файлы
(такие как init.ora и файл параметров сервера [SPFILE]), файлы сетевого администрирования (типа tnsnames.ora и listener.ora), файлы журналов предупреждений, файлы
трассировки, файл паролей и архив логов.

### Логическая структура

Логическая структура включает в себя:

**Табличные пространства.** Табличное пространство (tablespace) — набор из одного или более файлов данных, обычно состоящий из связанных сегментов. Файлы данных
содержат в себе все логические структуры, являющиеся частью табличного пространства, вроде таблиц и индексов.

**Сегменты.** Сегмент (segment) — набор экстентов, которые вы выделяете логической структуре, такой как таблица или индекс (либо некоторый другой объект).

**Экстенты.** Экстент (extent) — это два или более последовательных блоков данных Oracle, представляющий собой единицу выделения места на диске.

**Блоки данных.** Блок данных (data block) — мельчайший строительный блок базы данных Oracle, состоящий из определенного количества байт на диске.

### Файлы данных (Data Files).

Все данные в базе данных Oracle сохраняются в файлах данных. Все таблицы, индексы, триггеры, последовательности, программы
на PL/SQL, представления - все это находится в файлах данных.

### Оперативные файлы журналов повтора (Online Redo Log Files).

Предназначены для записи всех изменений, выполненных над данными базы данных Oracle. Используется для хранения на диске
информации для повторного выполнения операций.

### Управляющие файлы (Control Files).

Поскольку база данных Oracle является физическим набором связанных файлов данных, то для их синхронизации и контроля
требуется особые методы. Для этих целей используются управляющие файлы.

База данных Oracle может иметь один или несколько управляющих файлов. Если имеется несколько управляющих файлов, все они
должны быть абсолютно идентичными. При каждом запуске базы данных Oracle читает информацию управляющего файла, а при
каждом изменении размещения или добавления новых файлов данных и журналов базы данных обновляет управляющий файл.

### Файлы параметров pfile, spfie (Parameter Files).

Файлы параметров используются для конфигурирования действий Oracle предже всего при старте. Для того, чтобы запустить
экземпляр базы данных, Oracle должен прочесть файл параметров и определить, какие параметры инициализации установлены для
этого экземпляра. В файле параметров содержатся многочисленные параметры и их установленные значения. Oracle считывает
файл параметров при запуске базы данных. Можно создать несколько файлов параметров, каждый будет соответствовать различным
конфигурациям экземпляра.

###### *spfile* - бинарный файл, который используется сервером Oracle при старте. ####/u01/app/oracle/product/12.2.0/ dbhome_1/dbs
###### *pfile* - текстовый файл с параметрами, будет использоваться при старте, если не будет найден spfile.

Преимущество spfile заключается в том, что при работе с базой данных, любые изменения в базе касающиеся изменения
параметра системы, автоматически записываются в данный файл. Если используется pfile, для сохранения изменений, необходимо
либо “руками вносить эти изменения” в текстовый файл, либо в консоли выполнять команды для создания данных файлов Ораклом.

### Архивные файлы журналов повтора (Archive Log Files).

Как только оперативный файл журнала повтора (Redolog) оказывается заполнен, программное обеспечение сервера Oracle
начинает запись в следующий файл. Эта операция повторяется, как следствие информация в оперативных файлах журнала
(Redolog) многократно перезаписывается.
Если необходимо сохранить историю изменений, нужно, чтобы после переключения журналов сохранялась их копия. Для этого
достаточно перевести работу базы данных в режим работы ARCHIVELOG.

Архивные файлы журналов повтора жизненно важны при восстановлении. Если часть базы данных потеряна или повреждена, то для
устранения повреждений обычно требуется несколько архивных журналов. Файлы журналов повтора должны применяться к базе
данных последовательно. Если один из архивных файлов журналов повтора пропущен, то остальные архивные файлы журналов не
могут использоваться. Храните все свои архивные файлы журналов повтора с момента выполнения последней резервной копии.
Файлы журналов постепенно накапливаются и разрастаются. Иногда необходимо их удалять. Все операции с данными файлами по
применению их к базе выполняются исключительно средствами базы данных. А копировать и переносить их при желании можно как
угодно. Бездумно удалять их руками не рекомендуется.

##### ARCHIVELOG.

Режим работы базы данных, при котором после переключения активной журнальной группы, копия журнала архивируется и
сохраняется на диск. Redo-лог журналы постепенно перезаписываются, а информация которая в них хранилась может быть
получена из архивлогов.
В режиме работы ARCHIVELOG архивные журналы накапливаются и если свободного места нет, база данных прекращает работу. Если
свободного места совсем нет, можно застрять надолго.
В режиме работы ARCHIVELOG для создания бекапа не нужно останавливать работу базы, поэтому обычно базы данных работают
именно в этом режиме.

FRA (Fast Recovery Area) -область на диске для резервных копий и архивных журналов. Впрочем совсем необязательно хранить
бекапы именно в ней. Преимущество использования - возможность ограничения использования ресурсов жестких дисков для
бекапов и архивных журналов. В настройка Oracle задается, где эта область располагается и сколько в ней может храниться
данных. Лучше под FRA не задавать максимально большое значение которое можно выделить под эту задачу, чтобы если что иметь
возможность для маневра. По хорошему, нужно мониторить свободное место в FRA. Если место закончится, сервер отановится.

### Alert log и трассировочные файлы (trace file).

При работе базы данных события и ошибки регистрируются в текстовых файлах на сервере базы данных. Файл журнала
предупреждений (alert log) нужен администратору базы данных для отслеживания важнейших действий с базой данных - наподобие
открытия и закрытия базы данных, установления параметров загрузки базы данных и переключения оперативных журналов повтора.
Также в эти файлы записываются многие ошибки базы данных для последующего расследования их причин. Любые структурные
изменения базы данных также регистрируются в файле журнала предупреждений.

##### Alert log находится:
		/u01/app/oracle/diag/rdbms/valentin/valentin/trace    ## где valentin это имя instance #####
		SQL> show parapeter diag  
		SQL> select value from v$diag_info where name='Diag Trace';
### Файлы паролей (Password File).
Необязательный файл, используется для защиты информации о подключениях привилегированных пользователей. Если отсутствует,
то вы можете выполнять администрирование своей базы данных, только локально. Кроме того, с его помощью контролируется
количество привилегированных подключений для управления в одно и то же время.

# SGA (system global area).

Экземпляр БД Oracle состоит из блоков разделяемой памяти, называемых system global area (SGA) и background процессов.

SGA содержит три обязательные структуры данных:

```
Thedatabasebuffercache - содержит копии блоков данных считанные из файлов данных

Thelogbuffer - содержит данные о транзакциях которые ещё не записаны в redolog

Thesharedpool - содержит проверенные SQL выражения и кэш словаря данных, содержащий таблицы, представления и триггеры
```
    Также дополнительно могут быть:
    Largepool
    Javapool
    Streemspool

*Пользовательские сессии тоже требуют памяти на сервере. Это неразделяемая область памяти, которая
называется PGA. У каждой сессии своя PGA.*

### Database buffer cache – это область где выполняются SQL команды.

Когда мы обновляем данные, они не изменяются непосредственно в файлах данных на жёстком диске. Блоки данных, которые
содержат данные с которыми мы работаем вначале
копируются в buffer cache.
Изменения (вставка, измнение или удаление данных) применяются к этим копиям данных в буфферном кэше.
Когда мы хотим посмотреть какие-то данные – операция выдачи информации тоже происходит через кэш. Вначале находятся блоки
данных которые мы запросили и копируются в
буфер кэш; Затем нужные данные переносятся в PGA для дальнейшей обработки.

### Буфер логов (log buffer).

Log buffer – это небольшая, краткосрочная выделенная область памяти для хранения записей изменений (change vector) до
записи их в журнал (redo log) на диске. Запись
изменений – это изменение произошедшее с чем либо;выполнений DML команд создаёт записи изменений.Сохранение всех таких
записей это гарантия того, что данные никогда
не будут утеряны.

### The shared pool.

Shared pool самая сложная область в SGA. Она состоит из под-областей, которые управляются Oracle сервером. Управление
этими структурами происходит автоматически.
Размер изменяется динамически в зависимости от использования, но не превышает размер всей области памяти.

Мы обсудим только 4 кмпонента:
```

Library cache

Data dictionary cache

PL/SQL area

SQL PL/SQL function result cache
```

Library cache это область памяти где хранятся последние выполненные запросы в разобранном виде.

Data dictionary cache иногда называют row cache. В нём хранятся определения использованных объектов: описания таблиц,
индексов, пользователей и другие мета-данные.
Хранения этих данных в кэше в памяти SGA, где они доступны для всех сессий, в отличии от чтения их со словаря данных с
диска, сильно увеличивает производительность
разбора команд.

Область PL/SQL (PL/SQL Area). Объектами PL/SQL являются процедуры, функции, пакеты, сложные типы, триггеры.Когда PL/SQL
объект вызывается сессией, необходимо
прочитать нужную информацию из словаря данных. Для того чтобы исключить повторное чтение, эти объекты кэшируются в
области PL/SQL в shared pool.

SQL Query and PL/SQL Function Result Cache.  Во многих приложениях, одинаковые запросы выполняются много раз,  или одной
сессией или разными. Создание этого кэша
позволило Oracle серверу хранить результаты подобных запросов в памяти. Когда запрос будет выполняться повторно вместо
его реального выполнения, результат возьмётся
из кэша.

##### Каждому серверному процессу, обслуживающему клиента, выделяется область приватной памяти, называемая областью
**PGA**. Область PGA представляет собой
неразделяемую область памяти, которая создается Oracle при запуске серверного процесса и автоматически освобождается по
завершении данного сеанса.

# Процессы экземпляра БД.

Background process-ы экземпляра запускаются при запуске инстанса и работают до его выключения.

Пять процессов, которые существуют очень давно: Sysmte Monitor (SMON), Process Monitor (PMON), Database Writer (DBWn),
Log Writer (LGWR) и Checkpoint process (CKPT).
```
SMON (системный монитор)

PMON (process monitor)

DBWn (Database Writer)

LGWR, Log Writer

CKPT, Checkpoint Process

MMON, Manageability Monitor

ARCn, Archiver
```

### SMON (системный монитор).

Основной задачей этого процесса является «подключение» (mounting) и «открытие» базы данных. SMON «подключается» используя файл управления (control file). Затем
«открывает» базу для работы путём поиска и проверки всех файлов данных и файлов журнало изменений. Как только база запущена, SMON ответственен за разные задачи к
примеру за объединение пустого места в файлах данных.

### PMON (process monitor).

Пользовательская сессия это пользовательский процесс подключенный к серверному процессу. Серверный процесс запускается когда сессия создается и уничтожается когда
сессия заканчивается. Обычное завершение сессии влючает в себя выход пользователя. Когда это происходит, серверный процесс будет аккуратно завершён. Если сессия
прерывается «неожиданным» образов (например пользовательский компьютер перезагрузился), то сессия остаётся «висеть» в памяти и должна быть как-то закрыта. PMON
смотрит за всеми серверными процессами и ищет «висящие» сессии. Если найдена такая сессия, PMON остановит серверный процесс, вернёт PGA память операционной системе
и отменит все неподтверждённые операции пользователя. #######PMON читает читает параметр файл и контрол файл.#############

### DBWn (Database Writer).

Всегда надо помнить что сессии не работают с информацией на диске. Они работают с данными в buffer cache. А уже database writer в дальнейшем записывает информацию
из buffer cache на диск. Database writer процессов может быть несколько (максимально 12) которые будут называться DBW0, DBW1 и т.д. Отсюда в сокращении буква n в
конце. По умолчанию один database writer на 8 процессоров.

### LGWR (Log Writer).

LGWR записывает информацию из буфера логов в файл лога на диске.

### CKPT (Checkpoint Process).

Когда приложение запрашивает данные, база складывает их в буферный кэш — область памяти в SGA. Когда данные изменяются,
база производит изменения не непосредственно
в файле данных, а в буферном кэше. Одновременно в отдельную область памяти — redo log buffer — записывается информация,
по которой, в случае необходимости, можно
будет повторить произошедшее изменение. Когда изменение фиксируется (commit), оно, опять же, не сбрасывается сразу в файл
данных, но информация из redo log buffer
сбрасывается в online redo лог — специально для этого предназначенный файл. До тех пор, пока изменение не записано в файл
данных, необходимо хранить информацию о
нём где-то на диске на тот случай, если база упадёт. Если, к примеру, выключится питание сервера, то, само собой, все
данные, хранящиеся в памяти, будут потеряны. В
этом случае redo лог — это единственное место, где хранится информация о произошедшем изменении. После рестарта базы
Oracle фактически повторит прошедшую
транзакцию, вновь изменит нужные блоки и сделает commit. Поэтому до тех пор, пока информация из redo лога не будет
сброшена в файл данных, повторно использовать
этот redo лог невозможно.

Специальный фоновый процесс базы данных DBWn по мере необходимости освобождает буферный кэш, а также выполняет событие
контрольной точки (checkpoint). Контрольная
точка — это событие, во время которого «грязные» (изменённые) блоки записываются в файлы данных.

*За событие контрольной точки отвечает процесс CKPT (checkpoint process)*, который и пишет информацию о контрольной точке
в control file и заголовки файлов
данных. Событие контрольной точки обеспечивает согласованность данных и быстрое восстановление базы.

###### Потоковые контрольные точки (thread checkpoins).

В файл данных пишутся подряд все изменения, произошедшие в рамках определённого экземпляра до определённого момента.
Случаются они в следующих ситуациях:
```

полная остановка базы;

altersystemcheckpoint;

переключение online redo лога;

alter database begin backup.
```

###### Контрольные точки файлов данных и табличных пространств.

Случаются, когда происходят операции с табличными пространствами и файлами данных (alter tablespace offline, alter
tablespace read only, ужатие файла данных и.т.п.)

###### Инкрементальные контрольные точки.

Подвид контрольной точки экземпляра, предназначенный для того, чтобы избежать записи на диск огромного количества блоков
во время переключения redo логов.

###MMON, Manageability Monitor.

MMON — это процесс, который появился после версии 10g, и он позволяет использовать различные функции мониторинга и
оптимизации системы. Инстанс собирает различную
статистику о работе с БД и производительности. Эти данные хранятся в SGA и текущие значения можно просмотреть используя
SQL запросы. Для оптимизации
производительности, исторического анализа и анализа тренда изменений надо эти значения сохранять на протяжении отрезка времени. MMON регулярно (по умолчанию каждый
час) сохраняет значения из SGA в словарь данных, где эти данные могут храниться бесконечно (по умолчанию хранятся последние восемь дней).

Каждый раз при сохранении набора статистических данны (такой набор называют snapshot), MMON также запускает Automatic Database Diagnostic Monitor (ADDM). ADDM – это
иснтрумент анализа работы БД с помощью, разрабатываемый на протяжении многих лет различными DBA. Он сравнивает два snapshot-а (текущий и предыдущий) и на основании
анализа предлагает рекомендации по настройке БД.

###ARCn, Archiver.

Все записи об изменениях данных в буфере записываются в буфер логов и затем на диск процессом LGWR. Количество и разимер этих логов фиксированны. Когда они
заполняются, LGWR будет перезаписывать их новой информацией. Это значит что только последние изменения будут доступны. Чтобы сохранить полную историю – файлы логов
(online redo logs) необходимо скопировать перед тем как перезаписывать. Этим занимаются процессы ARCn. Если у нас есть эти копии (archive redo logs) то мы можем
восставонить информацию после любых сбоев. Вначале восстанавливается копия файлов данных на определенный момент времени, затем «накатываются» изменения из архива
логов с момента создания копии файлов данных, и в последнюю очередь восстанавливаются изменения из online redo log-ов.

#Описание этапов запуска и остановки БД

Нельзя запустить и остановить БД: только экземпляр может быть запущен и остановлен, а база данных может быть подключена, открыта, отключена и закрыта.
Необходимо помнить что экземпляр БД и база данных это два разных объекта которые могут существовать независимо друг от друга. Когда останавливается экземпляр БД то
структуры в памяти и фоновые процессы перестают существовать, однако база данных (содержимое файлов) продолжает.

**Процесс запуска базы данных разбит на шаги: вначале запускается экземпляр БД, затем база данных подключается (mount) и открывается (open) для использования. В
любой момент времени база данных может быть в одном из следующих состояний:**
```

SHUTDOWN

NOMOUNT необходим файл параметров

MOUNT использует файл контроля

OPEN читает файлы данных и файлы логов
```

Когда база данных остановлена (SHUTDOWN) все файлы закрыты и экземпляр не существует. В отключенном состоянии (NOMOUNT) – экземпляр БД построен в памяти (SGA
создана и фоновые процессы запущены согдасно файлу параметров), но база данных недоступна и может быть даже ещё не создана. В подключенном состоянии (MOUNT)
экземпляр находит и читает файл контроля. В открытом состоянии (OPEN) все файлы найдены и открыты – т.е. база данных доступна для пользователей. Когды вы запускаете
команду STARTUP – будут выполнены все шаги, однако команда может быть разбиты на этапы. Напирмер если файл контроля испорчен или копия недоступна – вы не сможете
подключить базу данных. Однако вы можете запустить базу в неподключенном режиме (NOMOUNT) и восстановить файл контроля. Точно так же если у вас возникли проблемы с
файлами данных или логовов, вы можете попробовать восстановить данные в MOUNT состоянии, перед тем как открывать БД.

*Когда вы запускаете команду STARTUP, Oracle будет искать файл параметров в определённом порядке:*
```

$ORACLE_HOME/dbs/spfileSID.ora
$ORACLE_HOME/dbs/spfile.ora
$ORACLE_HOME/dbs/initSID.ora
```

Во всех случаях – SID это имя экземпляра. Порядок поиска очень важен. Oracle будет использовать первый найденный файл вне
зависимости от наличия остальных. Если ни
одного файла не существует – экземпляр не будет запущен. В режиме NOMOUNT используются только файл параметров и системный
журнал. Значения параметров из файла
параметров используются для создания SGA в памяти и запуска фоновых процессов.

Когда экземпляр запущен в режиме NOMOUNT, переход в состояние MOUNT будет осуществляться путём чтения файла контроля.

**Остановка процесс зеркальный запуску.**

Вначале закрывается БД (CLOSE), затем отключается (DISMOUNT) и далее останавливается экземпляр. Во время закрытия БД все
сессии отключаются: текущие транзакции
отменяются процессом PMON, подтверждённые транзакции записываются в файлы данных DBWn и файлы данных и логов закрываются.
Во время отключения закрывается файл
контроля. И экземпляр останавливается с освобождением памяти и остановкой фоновых процессов.

Существуют параметры которые используются с командой SHUTDOWN :
```

SHUTDOWN [NORMAL|TRANSACTIONAL|IMMEDIATE|ABORT]

NORMAL: это значение по умолчанию. Новые подключения нельзя создать, но все текущие сессии могут работать до конца
сессии. Когда все пользователю отключатся база
данных будет выключена

TRANSACTIONAL: новые подключения недоступны; существующие сессии которые не выполняют транзакции отключаются; сессии
которые выполняют транзанкцию завершают
транзакцию и отключаются. Когда все сессии будут отключены, база данных останавливается.

IMMEDIATE: новые подключения не разрешены. Все активные сессии отключаются. Все активные транзакции отменяются и база
данных выключается.

ABORT: это эквивалент отключению питания. Экземпляр останавливается без записи чего либо на диск, закрытия файлов, отмены
транзакций.
```

# Использование системного журнала (Alert Log) и файлов трассировки (Trace Files).

###### Системный журнал это файл содержащий последовательные записи всех значимых операций совершённых над экземпляром БД
и самой базой данных. Местонахождение этого
файла
определяется параметром BACKGROUND_DUMP_DEST и имя alert_SID.log где SID это имя экзмепляра БД.

Значимым операциями записываемыми в системный журнал являются:
```

Запуск и остановка БД (включая шаги подключения и открытия)

Системные внутренние ошибки Oracle (например ошибка ORA-600)

Любые найденные повреждения блоков файлов данных

Возможные ситуации deadlock

Изменения физической структуры БД (создание/изменение файлов данных или файлов логов)

Выполнение команд ALTER SYSTEM

Переключение логов (log switch) и архивирование логов
```

*В системном журнале будут отображеные все значения параметров не по умолчанию при запуске системы. Эта информация вместе
со всеми записями выполнения команд ALTER
SYSTEM и ALTER DATABASE позволяют в любой момент времени восстановить историю изменений БД и экземпляра. Это может быть
незаменимой информацией при поиске источника
возникновения проблемы.*

###### Файлы трассировки создаются различными фоновыми процессами, обычно когда возникает ошибка. Эти файлы хранятся в
той же директории где и системный журнал. Если
фоновый процесс не отработал коррекно из-за какой либо ошибки – будет создан файл трассировки, который может помочь в
обнаружении проблемы.

# Использование словаря данных и динамических представлений производительности.

###### Словарь данных содержит метаданные: грубо говоря данные о данных.

Он содержит описание базы данных, физическую и логическую структуру и содержание БД. Учётные записи, информация о
безопасности, целостные ограничения и (начиная с версии 10g) информацию о производительности – всё это хранится в словаре
данных. Логически это набор сегментов в табличных пространствах SYSTEM и SYSAUX.

**Для просмотра словаря данных, Oracle предоставляет набор представлений, отличающихся префиксом: DBA_, ALL_ или USER_. **

Любое представление начинающееся с USER_ отобразит инфомрацию об объектах, владельцем которых является текущий
пользователь.

Представления начинающиеся с ALL_ отображают объекты, к которым у текущего пользователя есть доступ.

Представление с префиксом DBA_ содержит информацию о всех объектах в БД.

Существует несколько сот представлений словаря данных. Некоторые часто используемые DBA это:
```

DBA_OBJECT содержит строки для всех объектов в БД

DBA_DATA_FILES каждая строка описаывает файл данных

DBA_USER строки отображают информацию об учётной записи

DBA_TABLES описание таблиц

DBA_ALERT_HISTORY строки описывают последние события для записи в системный журнал
```

*Динамические представления производительности,их названия начинаются с V$. На самом деле,  “ви доллар” представления
совсем не представления – это синонимы созданные для представлений с префиксом V_$.*

Все они отображают информацию в режиме реального времени.

Представления которые содержат информацию об экземпляре БД доступны в любое время когда экземпляр запущен, даже в
состоянии NOMOUNT. Представления, которые содержат информацию из файла контроля, такие как V$DATABASE или V$DATAFILE
недоступны до подключения базы данных (момента, когда читается файл контроля). Для сравнения, представления словаря
данных могут использоваться только когда БД открыта.

Динамические представления произодительности создаются в момент запуска, обновляются на протяжении всей работы
экземпляра, и удаляются при выключении.

# Статические и динамические параметры. Инициализационный файл параметров

### *БД и экзмепляр управляются набором инилизационных параметров*

Эти параметры регулируют такие значения как объём выделяемой памяти при запуске экземпляра, местоположение файлов данных
и файлов логов, файла контроля и его копий, а также название БД.

Параметры используемые при создании экземпляра могут быть получены из файла параметров (который может быть статическим
pfile или динамическим spfile) или использовать значения по умолчанию.

*У всех параметров кроме DB_NAME есть значение по умолчанию*

Некоторые параметры могут быть измененые в процессе работы экземпляра БД. Другие же, называемые статическими параметрами,
устанавливаются только в момент запуска экземпляра БД. Изменение нестатических параметров приведёт к немедленному эффекту
на работающем экземпляре и также может быть записано в spfile. Если это будет сделано, то при следующей остановке/запуске
экземпляра будет использовано новое значение. Если не записывать изменения в файл – то изменения будут действовать только
до перезапуска экземпляра.  Статические параметры могут быть измененые только записью в spfile и изменения будут
применены при перезапуске экземпляра.

Oracle ищет подходящий файл параметров в следующем порядке:
```

Пытается использовать файл spfile${ORACLE_SID}.ora в директории $ORACLE_HOME/dbs

Пытается использовать файл spfile.ora в директории $ORACLE_HOME/dbs

Пытается использовать файл init${ORACLE_SID}.ora в директории $ORACLE_HOME/dbs
```

Изменение статических параметров не влияет на работу БД до перезапуска

Изменение остальных параметров влияет на работу без перезапуска, и может применяться как для экземпляра так и для
отдельной сессии.

# Клиент-Сервер

Серверный процесс работает на сервере базы данных и выполняет запросы, полученные от пользовательского процесса. Это
базовое клиент-серверное разделение: пользовательский процесс создаёт SQL, серверный процесс выполняет. Выполнение SQL
запроса происходит в четыре этапа: разбор (parse), связывание (bind), выполнение (execute) и выборка(fetch).  На этапе
разбора сервер определяет валиден ли запрос, какие объекты используются и как выполнить запрос максимально быстро. Разбор
использует shared pool: стурктуры памяти используются для преобразования SQL в исполняемый код. На этапе связывания – все
переменные преобразуются в литералы. Этап выполнения будет использовать SGA и возможно саму базу данных. Во время
выполнения данные в буфере кэша будут считываться или обновляться, изменения записываться в буфер логов, и если
необходимых блоков нету в буфере, серверный процесс считает их из файлов данных. Это единственный момент времени при
выполнении запроса когда используется сама база данных. И, наконец, на этапе выборки серверный процесс отправит
результирующий набор данных полученный в результате выполнения запроса назад пользовательскому процессу, и
пользовательский процесс преобразует результат для отображения.

**Пользователь взаимодействует с пользовательским процессом, пользовательский процесс в свою очередь взаимодействует с
серверным процессом используя Oracle Net; серверный процесс работает с экземпляром БД и экземпляр при помощи фоновых
процессов работает с базой данных.**

Listener определяется в файле listener.ora который по умолчанию находится в папке ORACLE_HOME/network/admin. Как минимум
файл listener.ora должен содержать информацию об одном listener-e, включая имя listener-а, протокол и адресс. Вы можете
настроить несколько listener-ов в одном файле, однако все они должны иметь уникальное имя и адресс.

пример файла listener.ora:
```
LISTENER =
    (DESCRIPTION =
        (ADDRESS = (PROTOCOL = TCP)(HOST = jwlnx1)(PORT = 1521))
    )

LIST2 =
    (DESCRIPTION =
        (ADDRESS_LIST =
            (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1522))
            (ADDRESS = (PROTOCOL = TCP)(HOST = jwlnx1.bplc.co.za)(PORT = 1522))
        )
    )
```

В первой секции описан listener с именем LISTENER, который использует локальное имя хоста на порту по умолчанию, 1521. Во
второй секции определён второй listener с именем LIST2. Он мониторит порт 1522 также на локальном имене хоста и адресе
замыкания (loopback/127.0.0.1).

**Для создания listener-а всё что нужно сделать это добавить запись в файл listener.ora и запустить его выполнив команду
lsnrctl.**

### Статическая регистрация.

Для статической регистрации экземпляра необходимо создать соответствующую запись в файле listener.ora.
```
SID_LIST_LISTENER=
   (SID_LIST=
        (SID_DESC=
          (GLOBAL_DBNAME=valentin)
          (SID_NAME=valentin)
          (ORACLE_HOME=/u01/app/oracle/product/12.2.0/dbhome_1)
```

### Динамическая регистрация.

Этот метод регистрации является предпочтительным, когда экземпляр регистрирует себя у listener-а.

### Методы определения имени.

###### Easy connect

Доступен при использовании только одного протокола: TCP.

connect store/admin123@jwlnxl.bplc.co:1522/ocp11g

В этом примере пользовательский процесс используя TCP протокол подключится к порту 1522 по IP адрессу определённому из
имени хоста. Если listener запущен на этом порту этого сервера – пользовательский процесс запросит listener создать
серверный процесс на instance ocp11g.

###### Local Naming.

Используя эту технику пользователь использует псевдоним (Oracle Net service alias) в строке подключения, а псевдоним
преобразуется в сетевой адресс, протокол, сервис или имя экземпляра с помощью локального файла. Этот файл и есть
tnsnames.ora. Рассмотрим пример файла tnsnames.ora
```

ocp11g =

    (DESCRIPTION =
        (ADDRESS_LIST =
          (ADDRESS = (PROTOCOL = TCP)(HOST = jwlnx1.bplc.co.za)(PORT = 1522))
        )
(CONNECT_DATA =
    (service_name = ocp11g)
)
    )

test =

    (DESCRIPTION =
        (ADDRESS_LIST =
            (ADDRESS = (PROTOCOL = TCP)(HOST = serv2.bplc.co.za)(PORT = 1521))
        )
              (CONNECT_DATA =
                    (sid = testdb)
              )
    )
```

Этот файл содержит два Oracle Net Service alias: ocp11g и test. Эти псевдонимы и есть то, что будут использовать
пользователи в строке подключения. Первый псевдоним ocp11g указывает на то, что если в строке подключения найдено
«@ocp11g», то пользовательский процесс по протоколу TCP, порту 1522 подключится к машине jwlnx1.bplc.co.za и попросит
listener создать сессию для экземпляра с названием сервиса ocp11g. Второй алиас test направит пользовательские процессы по
другому адресу, порту и сессии будут создаваться для экземпляра testdb.


###### Directory Naming и External Naming.

Метод Directory Naming направляет пользовательскую сессию к серверу LDAP для определения псевдонима
External Naming отличается от directory naming только тем, что использует отдельный сервис вместо LDAP – Sun Network
Information Services (NIS+) или Cell Directory Services (CDS).

###### Используется три важных файла для настройки Oracle Net:

listener.ora файл на стороне сервера, определяющий listener-ы БД. Влючает в себя сведения о протоколе, адресах и портах,
используемых listener-ом для ожидания запросов на подключения. А также может содержать информацию о статических
зарегистрированных экземплярах БД.

tnsnames.ora – файл со стороны клиента используемый для определения имени. Используется пользовательским процессом для
нахождения listener-ов БД.Также может быть использован самим экземпляром БД для нахождения listener-ов для динамической
регистрации.

sqlnet.ora – файл необязательный, может существовать (и даже с разными значениями) как на клиентской, так и на серверной
стороне. Содержит настройки которые могут применяться ко всем сессиям к listener-ам, такие как настройки безопасности и
шифрования.

Все три файла по умолчанию находятся в папке ORACLE_HOME/network/admin. Можно изменить путь к ним с помощью системной
переменной: TNS_ADMIN. Эта переменная часто используется если сущуствует несколько домашних директорий Oracle. У обычного
сервера Oracle будет как минимум три домашних директории Oracle: одна для Enterprise Manager Grid Control Agent, одна для
запуска экземпляров и одна для запуска экземпляров ASM (Automatic Storage Management).

В Unix и Linux синтаксис может отличаться в зависимости от исползуемой оболочки, но обычно выглядит примерно так
```

set TNS_ADMIN=/u01/oracle/net; export TNS_ADMIN
```

# DDL, DML, DCL, TCL.

DDL - (Data Defenition Language) предложения для определения структуры базы данных или схемы.

```

CREATE - создает объекты базы данных (таблицы, представления и т.д.)
ALTER - Изменяет структуру и объекты базы данных
DROP - Удаляет объекты базы данных
TRUNCATE - Удаляет все записи из таблицы
COMMENT - Добавляет комментарии в словарь данных
RENAME - Переименовывает объект (alter table <old_name> rename to <new_name>)
```

DML - (Data Manipulation Language) предложения для управления данными.

```

SELECT - Возвращает данные из базы данных
INSERT - Вставляет данные в таблицу
UPDATE - Обновляет существующие данные в таблице
DELETE - Удаляет все записи в таблице
MERGE - UPSERT операция (insert или update)
CALL - вызов подпрограммы PL/SQL или Java
EXPLAIN PLAN - Предоставляет план запроса
LOCK TABLE - Управление параллелизмом
```

DCL - Data Control Language.
```

GRANT - Дает пользователю привелегии доступа к базе данных и ее объектам
REVOKE - Забирает у пользователя привелегии данные командой GRANT
```

TCL - (Transaction Control) предложения используемые для управления изменениями сделанными предложениями DML. Это
позволяет объединять предложения DML в логические транзакции.

```

COMMIT - Сохраняет изменения
SAVEPOINT - Определяет точку транзакции до которой потом можно откатиться
ROLLBACK - Восстанавливает базу данных на момент последней операции COMMIT. Откатывает транзакцию
SET TRANSACTION - Изменяет опции транзакции, такие как: уровень изоляции и какой сегмент отката использовать
```

*Предложения DML автоматически не сохраняются, т.е. вы можете использовать откат транзакции, но результьтаты DDL
предложений сохраняются автоматически.*

# Объекты БД

*У всех объектов есть тип и имя, и любой объект принадлежит схеме.*

### Таблицы

Таблицы обычно хранят данные как строки состоящие из столбцов. Определение таблицы включает в себя такую
информацию как имя, владелец, сведения о столбцах, физическом расположении на диске и т.п. Эта информация является
метаданными. Содержимое таблиц хранится в виде строк и называется непосредственно данными.

### Представления

Представления хранят результат команды SELECT который может использоваться как будто это таблица.
Это обычный запрос но вместо того чтобы выполнять запрос и потом обрабатывать его, пользователь использует команду  
SELECT к представлению. Т.е. пользователь выполняет запрос к результату другого запроса.

### Синоним

Синоним это псевдоним к таблице (или представлению). Пользователь может выполнять запрос используя синоним а БД
преобразует запрос к объекту на который указывает синоним.

### Индексы

Индексы — это увеличение скорости доступа к строкам в таблице. Если запросу необходима всего одна строка, то вместо
просмотра всей таблицы для поиска нужной строки, индекс может предоставить указатель на расположение именно необходимой
строки.

### Сиквенс

Сиквенс используется для генерации уникальных чисел. Сиквенсы генерируют числа по порядку и по запросу: т.е. абсолютно
невозможна генерация дубликата.

###### Объекты PL/SQL

PL/SQL это язык третьего уровня который работает внутри БД. Вы можете использовать его для получения и обработки данных с
использованием SQL вместе с использованием конструкций функционального программирования таких как IF…THEN…ELSE и циклов
таких как FOR или WHILE.

PL/SQL выполняется на стороне БД но он может храниться как на клиентской стороне так и на стороне сервера.

Хранимый PL/SQL загружается в базу данных и хранится в словаре данных как именованный объект.

Когда он сохраняется в БД – он компилируется: процесс компиляции проверяет синтаксические ошибки и ошибки связанные с
объектами данных к которым обращается код.

Часто используется пять типов PL/SQL объектов: процедуры, функции, пакеты, тело пакета, триггер.

Все они являются объектами схемы и хранятся в словаре данных.

Процедуры и функции это подпрограммы обычно предназначенные для выполнения последовательных инструкций. Пакеты это
коллекции процедур и функций собранных вместе для более лёгкой управляемости. Триггеры нельзя поместить в пакет: они
ассоциируются с таблицами и выполняются в момент выполнения определённой DML команды к этой таблице.

# DML команды

Данные в реляционных базах данных управляются с помощью DML (Data Manipulation Language) комманд. Эти команды это INSERT,
UPDATE, DELETE и (в последних версиях SQL) MERGE.

Строго говоря существует пять DML команд:
```

SELECT

INSERT

UPDATE

DELETE

MERGE
```

*На практике профессионалы в области баз данных SELECT обычно не рассматривают как часть DML.*

*Команда MERGE тоже часто не рассматривается, не потому что это не чистая команды управления данными, а потому что
результат выполнения этой команды можно достичь используя другие команды*

*Команда часто рассматриваемая вместе с DML это команды TRUNCATE.*

###### Команда INSERT.

Команда INSERT может добавить одну строку в одну таблицу или много строк в много таблиц.

### Команда UPDATE.

Команда UPDATE используется для изменения строк которые уже существуют.

### Команда DELETE.

Команда DELETE-Эта команда удалит одну или несколько строк из таблицы в зависимости от условия в секции WHERE. Если
условие WHERE пропущено то все строки будут удалены из таблицы.

### Команда TRUNCATE.

Команда TRUNCATE это не команда DML – это команда DDL. Разница огромная. Когда DML команды работают с данными, они
добавляют, изменяют или удаляют данные как часть транзакции. С точки зрения пользователя, TRUNCATE таблицы тоже самое что
и DELETE всех строк. Но удаление может занять какое-то время (возможно несколько часов если достаточно много строк в
таблице), а TRUNCATE отработает мгновенно вне зависимости от количества строк в таблице.

### Команда MERGE.

Команда MERGE. Часто возникает ситуация когда вам необходимо взять набор данных (источник) и интегрировать его в
существующую таблицу (цель). Если строка источника уже существует в таблице-цели, вы можете хотеть обновить строку в
таблице-цели, или удалить старую строку и вставить новую или вы хотите вообще не трогать такие строки. Если строка
источника не существует в таблице-цели, вы хотите добавить такую строку. Команда MERGE позволяет сделать это.

Команда MERGE не делает ничего такого что было бы невозможно сделать командами DELETE, INSERT и UPDATE – но только она
может сделать это за один проход данных. Альтернативой команде MERGE будет три прохода данных, по одному для каждой
команды.

# Управление Транзакциями.

Транзакция состоит из одной или нескольких DML команд и следующей командой или ROLLBACK или COMMIT.

Механизм Oracle для обеспечения транзакционной целостности основан на сочетании сегментов отмены изменений и файла
журнала логов.

Любая реляционная база данных должна удовлетворять тесту ACID: должны быть гарантированы атомарность (A – atomicity),
согласованность (C – consistency), изолированность (I – isolation) и долговечность (D – durability).
```

Aтомарность. Принцип атомарности гласит что либо все части транзакции должны быть выполнены успешны либо ни одна из них.

Согласованность. Принцип согласованности данных гласит что результат запроса должен быть согласован с состояним базы
данных на момент старта работы запроса.

Изолированность. Принцип изолированности гласит что незаконченная (неподтверждённая транзакция) должна быть невидима для
остального мира.
Долговечность. Принцип долговечности указывает на то, что если транзакция успешно завершена, то должно быть невозможно
потерять эти данные.
```

### Управление транзакциями.
```
Транзакция это логическая единица работы, возможно состоящая из нескольких команд DML

Транзакции не видны другим сессиям пока не подтверждены

Пока транзакция не подтверждена она может быть отменена

Точка сохранения позволяет сессии отменить часть транзакции
```

### Управление данными с помощью команд DML.
```

Все команды DML создают данные повтора изменений (redo) и отката (undo)

Redo данные хранят все изменения сегментов – как сегментов данных, так и сегментов undo

Серверные процессы читают из файлов данных (используя буфер кэш); DBWn записывает данные в файлы данных
```

###### Undo

Все DML команды создают данные undo.

Данные undo используются для отменты транзакции и изоляции, а также для согласованности чтения и flashback запросов.

Данные undo всегда хранятся пока транзакция не завершена командой COMMIT или ROLLBACK. Это активные данные undo.

Данные undo сохраняются после того как они стали неактивными для согласованности чтения долгих запросов; это неустаревшие
данные undo.

Устаревшие данные не нужны для согласованности чтения и могут быть перезаписаны в любое время когда нужно место в
сегменте undo.

Экземпляр использует сегменты undo в одном явно указанном табличном пространтсве undo.

Другие табличные пространтсва undo могут существовать, но только одно может быть активным.

Табличное пространтсво undo должно быть достаточно большим чтобы вмещать данные при максимальной нагрузке в течении
времени выполнения самого долгого запроса.

Файлы данных в табличном пространстве undo такие же как и файлы данных обычного табличного пространства.

# Получение, ограничение и сортировка данных используя SQL.

### Команда DESCRIBE.

Команда DESCRIBE (может быть сокращена DESC) - описывает структуру таблицы.

Синтаксис команды :
```

DESCRIBE <schema>.tablename;
```

### Команда SELECT.

Команда SELECT  — команда для получения информации из таблицы.

Синтаксис простой команды SELECT:
```

SELECT * FROM <schema>.tablename; ###В таком формате символ * используется для обозначения всех столбцов

SELECT {[DISTINCT] column|expression [alias],…} FROM table;

			Использование ключевого слова DISTINCT позволит убрать дубликаты из результата.

			alias это альтернативное имя столбца или выражения.

			expression (выражения) – это обычно результат какой-либо операции над значениями одного (или нескольких) столбцов
			или выражений.
```

### Предикат WHERE.

Предикат WHERE расширяет команду SELECT предоставляя возможность ограничить строки результата наложением одного или
нескольких условий.

Синтаксис команды SELECT с предикатом WHERE выглядит следующим образом:
```

SELECT *|{[DISTINCT] column|expression [alias],…}

FROM table

[WHERE condition(s)];

Предикат WHERE всегда находится после предиката FROM. Квадратные скобки указывает на то что использование WHERE
необязательно. Одно или несколько условий могут применяться для ограничения результата. Условия определяется оператором
сравнения и двумя операндами. Операндами могут быть значения столбцов, литераты или выражения. Оператор равенства
(equality) наиболее часто используемые оператор для ограничения результата.
```

###### Операторы сравнения.
```

Равенство и неравенство.

Оператор BETWEEN проверяет входит ли значение столбца или выражение в диапазон установленный двумя граничными значениями.

Оператор IN проверяет является ли проверяемый элемент членом набора значений литералов.

Оператор LIKE использует два специальных символа для составления шаблона: символ процента (%) и нижнее подчеркивание (_).
Знак процента используется для указания нуля или более любых символов, а нижнее подчеркивание заменяет один любой символ.

Оператор IS NULL возвращает только те строки где в значении столбца именно значение NULL. Проверка значения на NULL
невозможна используя оператор  равенства.
```

###### Булевы операторы.
```

Оператор AND (логическое «И») объединяет условия в одно условие и только те данные которые выполняют все условия будут
включаться в результат.

Оператор OR  (логическое ИЛИ) разделяет два условия таким образом, что для попадания в результат данные должны
удовлетворять минимум одному условию.

Оператор NOT (логическое отрицание) отменяет операторы условия. То есть данные должны удовлетворять логически обратному
условию для попадания в результат.
```

### Предикат ORDER BY.

Предикат ORDER BY сортирует возвращаемый результат

Синтаксис SELECT с ключевым словом ORDER BY выглядит следующим образом:
```

SELECT *|{[DISTINCT] column|expression [alias],…}

FROM table

[WHERE condition(s)]

[ORDER BY {col(s)|expr|numeric_pos} [ASC|DESC] [NULLS FIRST|LAST]];
```

###### Подстановка амперсанта.

Иногда полезно иметь заготовку запроса, в которой указаны переменные, которые будут заменены на значения при выполнении
запроса. Символ амперсанта (&) выбран для назначения переменной в запросе и переменная состоит из амперсанта и названия
переменной без пробела между ними.

Подстановка переменной позволяет использовать написанный ранее запрос добавляя возможность заменить некоторые элементы во
время выполнения. Один и тот же запрос может быть выполнен несколько раз с указанием разных параметров.

Переменные сессии могут задаваться явно, используя команду DEFINE. Команда UNDEFINE позволяет удалить переменные сессии
включая явно созданные командой DEFINE и неявно созданные (используя двойной амперсант).

Команда VERIFY управляет выводом пользователю запроса до и после подстановки переменной.

# Oracle database link

Oracle database link— это одностороннее соединение локальной базы данных с удаленной базой данных. Связь всегда односторонняя.
